/*******************************************************************************
 * This file is auto generated by ChainStack, DO NOT MODIFY
 *
 * FileName : log.h
 * Desc     : Define contract data object.
 * History  :
 * License  :
 *******************************************************************************/

#ifndef CDL_PLANET_MODEL_H
#define CDL_PLANET_MODEL_H

#include "libs/commons_2.0.0/dependency.h"
#include "libs/commons_2.0.0/json_reader.h"
#include "libs/commons_2.0.0/json_writer.h"
#include "libs/commons_2.0.0/validator.h"

#define SF_TOKEN_ID           "tokenId"
#define SF_TOKEN_U_R_I           "tokenURI"
#define SF_AMOUNT           "amount"
#define SF_ITEM_ID           "itemId"
#define SF_OWNER           "owner"
#define SF_PRICE           "price"

using cstack::libs::commons::JsonReader;
using cstack::libs::commons::JsonWriter;
using cstack::libs::commons::Validator;

namespace planet {
namespace model {

struct Token {

	uint64_t token_id;

	std::string token_u_r_i;

	uint64_t amount;


    // token_id 字段是否存在
    bool token_id_exist = true;

    // token_u_r_i 字段是否存在
    bool token_u_r_i_exist = true;

    // amount 字段是否存在
    bool amount_exist = true;


    void set_token_id(const uint64_t& _value) {
        token_id = _value;
        token_id_exist = true;
    }

    uint64_t get_token_id() const {
        return token_id;
    }

    bool is_token_id_exist() const {
        return token_id_exist;
    }

    void set_token_u_r_i(const std::string& _value) {
        token_u_r_i = _value;
        token_u_r_i_exist = true;
    }

    std::string get_token_u_r_i() const {
        return token_u_r_i;
    }

    bool is_token_u_r_i_exist() const {
        return token_u_r_i_exist;
    }

    void set_amount(const uint64_t& _value) {
        amount = _value;
        amount_exist = true;
    }

    uint64_t get_amount() const {
        return amount;
    }

    bool is_amount_exist() const {
        return amount_exist;
    }

};

struct Commodity {

	uint64_t item_id;

	uint64_t token_id;

	std::string token_u_r_i;

	std::string owner;

	uint64_t price;

	uint64_t amount;


    // item_id 字段是否存在
    bool item_id_exist = true;

    // token_id 字段是否存在
    bool token_id_exist = true;

    // token_u_r_i 字段是否存在
    bool token_u_r_i_exist = true;

    // owner 字段是否存在
    bool owner_exist = true;

    // price 字段是否存在
    bool price_exist = true;

    // amount 字段是否存在
    bool amount_exist = true;


    void set_item_id(const uint64_t& _value) {
        item_id = _value;
        item_id_exist = true;
    }

    uint64_t get_item_id() const {
        return item_id;
    }

    bool is_item_id_exist() const {
        return item_id_exist;
    }

    void set_token_id(const uint64_t& _value) {
        token_id = _value;
        token_id_exist = true;
    }

    uint64_t get_token_id() const {
        return token_id;
    }

    bool is_token_id_exist() const {
        return token_id_exist;
    }

    void set_token_u_r_i(const std::string& _value) {
        token_u_r_i = _value;
        token_u_r_i_exist = true;
    }

    std::string get_token_u_r_i() const {
        return token_u_r_i;
    }

    bool is_token_u_r_i_exist() const {
        return token_u_r_i_exist;
    }

    void set_owner(const std::string& _value) {
        owner = _value;
        owner_exist = true;
    }

    std::string get_owner() const {
        return owner;
    }

    bool is_owner_exist() const {
        return owner_exist;
    }

    void set_price(const uint64_t& _value) {
        price = _value;
        price_exist = true;
    }

    uint64_t get_price() const {
        return price;
    }

    bool is_price_exist() const {
        return price_exist;
    }

    void set_amount(const uint64_t& _value) {
        amount = _value;
        amount_exist = true;
    }

    uint64_t get_amount() const {
        return amount;
    }

    bool is_amount_exist() const {
        return amount_exist;
    }

};


Token BuildToken();
void TokenJsonDecode(const std::string& data, Token& token);
void TokenJsonDecode(const rapidjson::Value::Object& object, Token& token);
void TokenJsonEncode(const Token& token, std::string& data);
void TokenJsonEncode(const Token& token, rapidjson::Value& json, rapidjson::Document::AllocatorType& allocator);

Commodity BuildCommodity();
void CommodityJsonDecode(const std::string& data, Commodity& commodity);
void CommodityJsonDecode(const rapidjson::Value::Object& object, Commodity& commodity);
void CommodityJsonEncode(const Commodity& commodity, std::string& data);
void CommodityJsonEncode(const Commodity& commodity, rapidjson::Value& json, rapidjson::Document::AllocatorType& allocator);


//// Token Model Method Definition

Token BuildToken() {
    Token token_model;
    token_model.token_id_exist = false;
    token_model.token_u_r_i_exist = false;
    token_model.amount_exist = false;
    return token_model;
}

void TokenJsonDecode(const std::string& data, Token& token){

    rapidjson::Value root;
	JsonReader::ParseObject(data, root);

	auto object = root.GetObject();

    TokenJsonDecode(object, token);
}

void TokenJsonDecode(const rapidjson::Value::Object& object, Token& token){
        Validator::RequiredFieldCheck(object, SF_TOKEN_ID);
	    JsonReader::GetUint64(object, SF_TOKEN_ID, token.token_id);

        Validator::RequiredFieldCheck(object, SF_TOKEN_U_R_I);
	    JsonReader::GetString(object, SF_TOKEN_U_R_I, token.token_u_r_i);

        Validator::RequiredFieldCheck(object, SF_AMOUNT);
	    JsonReader::GetUint64(object, SF_AMOUNT, token.amount);

}

void TokenJsonEncode(const Token& token, std::string& data){

    rapidjson::Value json(rapidjson::kObjectType);

    static rapidjson::Document doc;
	rapidjson::Document::AllocatorType& allocator = doc.GetAllocator();

    TokenJsonEncode(token, json, allocator);

    JsonWriter::Writer(json, data);
}

void TokenJsonEncode(const Token& token, rapidjson::Value& json, rapidjson::Document::AllocatorType& allocator){


    if (token.is_token_id_exist()) {
        rapidjson::Value token_id_value;
        JsonWriter::ToValue(token.token_id, token_id_value);
        json.AddMember(SF_TOKEN_ID, token_id_value, allocator);

    }

    if (token.is_token_u_r_i_exist()) {
        rapidjson::Value token_u_r_i_value;
        JsonWriter::ToValue(token.token_u_r_i, allocator, token_u_r_i_value);
        json.AddMember(SF_TOKEN_U_R_I, token_u_r_i_value, allocator);

    }

    if (token.is_amount_exist()) {
        rapidjson::Value amount_value;
        JsonWriter::ToValue(token.amount, amount_value);
        json.AddMember(SF_AMOUNT, amount_value, allocator);

    }
}

//// Token Model Definition End

//// Commodity Model Method Definition

Commodity BuildCommodity() {
    Commodity commodity_model;
    commodity_model.item_id_exist = false;
    commodity_model.token_id_exist = false;
    commodity_model.token_u_r_i_exist = false;
    commodity_model.owner_exist = false;
    commodity_model.price_exist = false;
    commodity_model.amount_exist = false;
    return commodity_model;
}

void CommodityJsonDecode(const std::string& data, Commodity& commodity){

    rapidjson::Value root;
	JsonReader::ParseObject(data, root);

	auto object = root.GetObject();

    CommodityJsonDecode(object, commodity);
}

void CommodityJsonDecode(const rapidjson::Value::Object& object, Commodity& commodity){
        Validator::RequiredFieldCheck(object, SF_ITEM_ID);
	    JsonReader::GetUint64(object, SF_ITEM_ID, commodity.item_id);

        Validator::RequiredFieldCheck(object, SF_TOKEN_ID);
	    JsonReader::GetUint64(object, SF_TOKEN_ID, commodity.token_id);

        Validator::RequiredFieldCheck(object, SF_TOKEN_U_R_I);
	    JsonReader::GetString(object, SF_TOKEN_U_R_I, commodity.token_u_r_i);

        Validator::RequiredFieldCheck(object, SF_OWNER);
	    JsonReader::GetString(object, SF_OWNER, commodity.owner);

        Validator::RequiredFieldCheck(object, SF_PRICE);
	    JsonReader::GetUint64(object, SF_PRICE, commodity.price);

        Validator::RequiredFieldCheck(object, SF_AMOUNT);
	    JsonReader::GetUint64(object, SF_AMOUNT, commodity.amount);

}

void CommodityJsonEncode(const Commodity& commodity, std::string& data){

    rapidjson::Value json(rapidjson::kObjectType);

    static rapidjson::Document doc;
	rapidjson::Document::AllocatorType& allocator = doc.GetAllocator();

    CommodityJsonEncode(commodity, json, allocator);

    JsonWriter::Writer(json, data);
}

void CommodityJsonEncode(const Commodity& commodity, rapidjson::Value& json, rapidjson::Document::AllocatorType& allocator){


    if (commodity.is_item_id_exist()) {
        rapidjson::Value item_id_value;
        JsonWriter::ToValue(commodity.item_id, item_id_value);
        json.AddMember(SF_ITEM_ID, item_id_value, allocator);

    }

    if (commodity.is_token_id_exist()) {
        rapidjson::Value token_id_value;
        JsonWriter::ToValue(commodity.token_id, token_id_value);
        json.AddMember(SF_TOKEN_ID, token_id_value, allocator);

    }

    if (commodity.is_token_u_r_i_exist()) {
        rapidjson::Value token_u_r_i_value;
        JsonWriter::ToValue(commodity.token_u_r_i, allocator, token_u_r_i_value);
        json.AddMember(SF_TOKEN_U_R_I, token_u_r_i_value, allocator);

    }

    if (commodity.is_owner_exist()) {
        rapidjson::Value owner_value;
        JsonWriter::ToValue(commodity.owner, allocator, owner_value);
        json.AddMember(SF_OWNER, owner_value, allocator);

    }

    if (commodity.is_price_exist()) {
        rapidjson::Value price_value;
        JsonWriter::ToValue(commodity.price, price_value);
        json.AddMember(SF_PRICE, price_value, allocator);

    }

    if (commodity.is_amount_exist()) {
        rapidjson::Value amount_value;
        JsonWriter::ToValue(commodity.amount, amount_value);
        json.AddMember(SF_AMOUNT, amount_value, allocator);

    }
}

//// Commodity Model Definition End


} // namespace base
} // namespace planet

#endif //CDL_PLANET_MODEL_H